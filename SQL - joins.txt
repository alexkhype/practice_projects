* A key field is a single column or group of columns that uniquely identifies records in a table. 

INNER JOIN shown looks for records in both tables with the same values in the key field, and ignores any records that do not. 

(1) After FROM, we list the left table, 
(2) followed by the INNER JOIN keyword and the right table. 
(3) We then specify the field to match the tables on, using the ON keyword. 
(4) Lastly, we add SELECT at the start of the query and choose the fields we want returned. 

    (4) SELECT p2.country, p2.continent, primer minister, president
    (1) FROM presidents AS p1                (table  on the left)
    (2) INNER JOIN prime_ministers AS p2     (table on the right)
    (3) ON p1.country = p2.country; 
    (or) USING (country)

When selecting columns that exist in both tables, the table.column_name format must be used to avoid a SQL error. Otherwise, it is not necessary.

We can alias table names using the same AS keyword used to alias column names. 

When joining on two identical column names, we can employ the USING command followed by the shared column name in parentheses. Here, since the join field is named "country" in both tables, we can use USING. 

When writing joins, many SQL users prefer to write the SELECT statement after writing the join code, in case the SELECT statement requires using table aliases.

-- Select name fields (with alias) and region 
SELECT cities.name AS city, countries.name AS country, countries.region
FROM cities;
-- Inner join to countries
INNER JOIN countries
-- Match on country codes
ON cities.country_code = countries.code;

-- Select fields with aliases
SELECT c.code AS country_code, name, year, inflation_rate
FROM countries AS c
-- Join to economies (alias e)
INNER JOIN economies AS e 
-- Match on code field using table aliases
ON c.code = e.code

SELECT c.name AS country, l.name AS language, official
FROM countries AS c
INNER JOIN languages AS l
-- Match using the code column
USING(code);


One-to-many relationship: a single entity can be associated with several entities.
One-to-one relationship: unique pairings between entities
Many-to-many relationship: 


-- Select country and language names (aliased)
SELECT c.name AS country, l.name as language
-- From countries (aliased)
FROM countries AS c
-- Join to language (aliased)
INNER JOIN languages AS l
-- Use code as the joining field with the USING keyword
USING(code)
-- Filter for the Bhojpuri language
WHERE l.name = 'Bhojpuri';



SELECT *
FROM left_table
INNER JOIN right_table
ON left_table.id = right_table.id
INNER JOIN another_table
ON left_table.id = another_table.id;

SELECT p1.country, p1.continent,
       president, prime_minister
FROM prime_ministers AS p1
INNER JOIN presidents AS p2
USING(country)
INNER JOIN prime_minister_term AS p3
USING(prime_minister);


SELECT *
FROM left_table
INNER JOIN right_table
ON left_table.id = right_table.id
    AND left_table.date = right_table.date

-- Select relevant fields
SELECT name, e.year, fertility_rate, unemployment_rate
-- Inner join countries and populations, aliased, on code
FROM countries AS c
INNER JOIN populations AS p
ON c.code = p.country_code
-- Join to economies (as e)
INNER JOIN economies AS e
-- Match on country code
ON c.code = e.code
-- Add an additional joining condition such that you are also joining on year
	AND e.year = p.year;




With the INNER JOIN the only records in the result were those where the id field had matching values in both tables. 

OUTER JOINS

LEFT (OUTER) JOIN will return all records in the left table, and those records in the right table that match on the joining field provided. LEFT JOIN keeps all records in left_table, as well as null values for right_val where is no match in right_table.

SELECT p1.country, prime_minister, president
FROM prime_ministers AS p1
LEFT JOIN presidents AS p2
USING(country)

Aquí, prime_ministers está a la izquierda y se le ha pegado las columnas relevantes de presidents

RIGHT (OUTER) JOIN will return all records in the right table, and those records in the left table that match on the joining field provided. RIGHT JOIN keeps all records in right_table, as well as null values for left_val where is no match in left_table. when converting a LEFT JOIN to a RIGHT JOIN, change both the type of join and the order of the tables to get equivalent results. 

SELECT p1.country, prime_minister, president
FROM prime_ministers AS p1
RIGHT JOIN presidents AS p2
USING(country)

SELECT 
    c1.name AS city,
    code,
    c2.name AS country,
    region,
    city_proper_pop
FROM cities AS c1
-- Perform an inner join with cities as c1 and countries as c2 on country code
INNER JOIN countries AS c2
ON c1.country_code = c2.code
ORDER BY code DESC;


-- Select region, and average gdp_percapita as avg_gdp
SELECT 
    region,
    AVG(gdp_percapita) AS avg_gdp
FROM countries AS c
LEFT JOIN economies AS e
-- Match on code fields
USING(code)
-- Filter for the year 2010
WHERE year = 2010
-- Group by region
GROUP BY region
-- Order by descending avg_gdp
ORDER BY avg_gdp DESC
-- Return only first 10 records
LIMIT 10;

FULL JOIN

FULL (OUTER) JOIN will return all ids, irrespective of whether they have a match in the other table being joined. 

SELECT left_table.id AS L_id,
    right_table.id AS R_id,
    left_table.val AS L_val,
    right_table.val AS R_val
FROM left_table
FULL JOIN right table
USING (id);

SELECT p1.country AS country, prime_minister, president
FROM prime_ministers AS p1
FULL JOIN presidents AS p2
ON p1.country = p2.country
LIMIT 10;

SELECT 
	c1.name AS country, 
    region, 
    l.name AS language,
	basic_unit, 
    frac_unit
FROM countries as c1 
-- Full join with languages (alias as l)
FULL JOIN languages AS l
USING(code)
-- Full join with currencies (alias as c2)
FULL JOIN currencies AS c2
USING(code) 
WHERE region LIKE 'M%esia';






CROSS JOIN

CROSS JOIN creates all possible combinations of two tables. We have two tables named table1 and table2, with one field each: id1 and id2, respectively. The result of the CROSS JOIN is all nine combinations of the id values of 1, 2, and 3 in table1 with the id values of A, B, and C for table2. 

SELECT id1, id2
FROM table1
CROSS JOIN table2;

SELECT c.name AS country, l.name AS language
FROM countries AS c        
-- Perform a cross join to languages (alias as l)
CROSS JOIN languages as l
WHERE c.code in ('PAK','IND')
	AND l.code in ('PAK','IND'); 
-- WARNING, THIS GIVES DUPLICATES




SELECT 
	c.name AS country,
    region,
    life_expectancy AS life_exp
FROM countries AS c
-- Join to populations (alias as p) using an appropriate join
LEFT JOIN populations AS p
ON c.code = p.country_code
-- Filter for only results in the year 2010
WHERE year = 2010
-- Sort by life_exp
ORDER BY life_exp
-- Limit to five records
LIMIT 5;




SELF JOIN

SELF JOIN is a special kind of join, where a table is joined with itself. Self joins are used to compare values from part of a table to other values from within the same table. 

Self joins don't have dedicated syntax as other joins we have seen do. In addition, aliasing is required for a self join. Let's look at a chunk of INNER JOIN code using the prime_ministers table. The country column is selected twice, and so is the continent column. The prime_ministers table is on both the left and the right of the JOIN, making this both a self join and an INNER JOIN! The vital step here is setting the joining fields which we use to match the table to itself. For each country, we will find multiple matched countries in the right table, since we are joining on continent. Each of these matched countries will be returned as pairs. 

SELECT
    p1.country AS country1,
    p2.country AS country2,
    p1.continent
FROM prime_ministers AS p1
INNER JOIN prime_ministers AS p2
ON p1.continent = p2.continent
-- Exclude identical pairs
    AND p1.country <> p2.country;  


-- Select aliased fields from populations as p1
SELECT p1.country_code,
    p1.size AS size2010,
    p2.size AS size2015
-- Join populations as p1 to itself, alias as p2, on country code
FROM populations AS p1
INNER JOIN populations AS p2
USING(country_code)
WHERE p1.year = 2010
-- Filter such that p1.year is always five years before p2.year
    AND p1.year = p2.year - 5


**************************
***   SET OPERATIONS   ***
**************************

UNION
=====

    UNION takes two tables as input, and returns all records from both tables
    If two records are identical, UNION only returns them once.

    UNION ALL takes two tables and returns ALL records  from both tables,
    including duplicates

SELECT *
FROM left_table
UNION
SELECT * 
FROM right_table;

SELECT *
FROM left_table
UNION ALL
SELECT * 
FROM right_table;

    Note that set operations do not require a field to join ON. Rather than comparing and merging tables on the left and right, they stack fields on top of one another. 
For all set operations, the number of selected columns and their respective data types must be identical.
The result will only use field names (or aliases, if used) of the first SELECT statement in the query. 

SELECT monarch AS leader, country
FROM monarchs
UNION
SELECT prime_minister, country
FROM prime_ministers
ORDER BY country, leader
LIMIT 10;

    When drafting queries containing set operations, it is often helpful to write the queries on either side of the operation first, and then call the set operator. 

-- Select all fields from economies2015
SELECT * 
FROM economies2015
-- Set operation
UNION
-- Select all fields from economies2019
SELECT *
FROM economies2019
ORDER BY code, year;

INTERSECT
=========

    INTERSECT takes two tables as input, and returns only the records that exist in both tables (i.e. that are exactly the same) 

SELECT *
FROM left_table
INTERSECT
SELECT * 
FROM right_table;

     In INNER JOIN, similar to INTERSECT, only results where both fields match are returned. INNER JOIN will return duplicate values, whereas INTERSECT will only return common records once. As we know from earlier lessons, INNER JOIN will add more columns to the result set. 

SELECT country AS intersect_country
FROM prime_ministers
INTERSECT
SELECT country
FROM presidents;

-- Return all cities with the same name as a country
SELECT name
FROM countries
INTERSECT
SELECT name
FROM cities;

EXCEPT
======

EXCEPT allows us to identify the records that are present in one table, but not the other. More specifically, it retains only records from the left table that are not present in the right table. 

--Return the monarchs that are not prime ministers
SELECT monarch, country
FROM monarchs
EXCEPT
SELECT prime_minister, country
FROM prime_ministers;

-- Return all cities that do not have the same name as a country
SELECT name
FROM cities
EXCEPT
SELECT name
FROM countries;